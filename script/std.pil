> noop
<

### BUILTINS

# builtin: write.byte
$ write.byte:value Int8



### CONST_STR


> const_str.try_get
. const_str.len:value const_str.try_get:value
| const_str.len
. int32.lt:x const_str.len:result
. int32.lt:y const_str.try_get:index
| int32.lt
. const_str.try_get:valid int32.lt:result
= const_str.try_get@?
[ const_str.try_get@? const_str.try_get:valid
? 1 const_str.try_get@valid
? 0 const_str.try_get@invalid
]
> const_str.get@valid
. const_str.get:value const_str.try_get:value
. const_str.get:index const_str.try_get:index
| const_str.get
. const_str.try_get:result const_str.get:result
<
> const_str.get@invalid
. const_str.try_get:result 0
<
$ const_str.try_get:value ConstStr
$ const_str.try_get:index Int32
$ const_str.try_get:valid Int1
$ const_str.try_get:result Int8


> const_str.contains
+ const_str.contains@i 0
= const_str.contains@loop
> const_str.contains@loop
. const_str.try_get:value const_str.contains:str
. const_str.try_get:index const_str.contains@i
| const_str.try_get
. const_str.contains:result const_str.try_get:valid
= const_str.contains@?
[ const_str.contains@? const_str.contains:result
? 1 const_str.contains@check
? 0 noop
]
> const_str.contains@check
. int8.eq:x const_str.try_get:result
. int8.eq:y const_str.contains:value
| int8.eq
. const_str.contains:result int8.eq
= const_str.contains@??
[ const_str.contains@?? const_str.contains:result
? 1 noop
? 0 const_str.contains@loop
]
$ const_str.contains:value Int8
$ const_str.contains:str ConstStr
$ const_str.contains:result Int1
$ const_str.contains@i Int32


### WRITE

> write.newline
+ write.byte:value '\n'
= write.byte

> write.const_str
+ write.const_str@i 0
= write.const_str@cond
> write.const_str@loop
. const_str.get:value write.const_str:value
. const_str.get:index write.const_str@i
| const_str.get
. write.byte:value const_str.get:result
| write.byte
. int32.inc:x write.const_str@i
| int32.inc
. write.const_str@i int32.inc:result
= write.const_str@cond
> write.const_str@cond
. const_str.len:value write.const_str:value
| const_str.len
. int32.lt:x write.const_str@i
. int32.lt:y const_str.len:result
| int32.lt
= write.const_str@switch
[ write.const_str@switch int32.lt:result
? 1 write.const_str@loop
! noop
$ write.const_str:value ConstStr
$ write.const_str@i Int32

> write.int32
. int32.cmpz:x write.int32:value
| int32.cmpz
= write.int32@?

[ write.int32@? int32.cmpz:result
? -1 write.int32@-
! write.int32@+

> write.int32@+
. write.nat32:value write.int32:value
= write.nat32

> write.int32@-
+ write.byte:value '-'
| write.byte
. int32.neg:x write.nat32:value
| int32.neg
. write.nat32:value int32.neg:result
= write.nat32
$ write.int32:value Int32

> write.nat32
. int32.divmod:x write.nat32:value
+ int32.divmod:y 10
| int32.divmod
. write.nat32:value int32.divmod:div
. int32.add:x int32.divmod:mod
+ int32.add:y '0'
| int32.add
. int32.to_8:value int32.add:result
| int32.to_8
. write@stack.push:value int32.to_8:result
| write@stack.push
= write.nat32:switch
[ write.nat32:switch write.nat32:value
? 0 write@stack
! write.nat32
$ write.nat32:value Int32

> write@stack.push
{ write@stack write@stack@index write@stack.push:value
. int5.inc:x write@stack@index
| int5.inc
. write@stack@index int5.inc:result
<
$ write@stack.push:value Int8

# NOTE: values *must* have been written to the stack
> write@stack
. int5.dec:x write@stack@index
| int5.dec
. write@stack@index int5.dec:result
} write@stack write@stack@index write.byte:value
| write.byte
= write@stack@?
[ write@stack@? write@stack@index
? 0 noop
! write@stack

$ write@stack@index Int5
@ write@stack Int5 Int8
